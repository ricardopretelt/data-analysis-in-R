---
title: "Data analysis in R"
output: html_notebook
---
### To assign values to a variable
```{r}
x<-1
x
```
```{r}
# To print values in console
print(x)
```
```{r}
# To assign a character value
msg<-"hello"
msg
```
```{r}
# To assign a vector
x1<-1:20
x1
```
```{r}
# To assign an integer
int<-2L
int
```
### To use infinity
```{r}
int/Inf
```
### To concatenate values
```{r}
c(0.5, 0.6)
```
### To change values to logic
```{r}
as.logical(x1)
```
### To create a list (It can contain values of different types)
```{r}
list_x<-list(1,"a", TRUE, 1+4i, 2L)
list_x
```
### Use of vectors
```{r}
# To concatenate vectors by rows
x2<-1:3
y2<-7:9
rbind(x2,y2)
```
```{r}
# To concatenate vectors by columns
cbind(x2,y2)
```
### Use of matrix
```{r}
# To create an empty matrix
mat<-matrix(nrow=2, ncol=3)
mat
```
```{r}
# To see the dimension of the matrix created
dim(mat)
```
```{r}
# To see the attributes of the matrix. In this case its dimension
attributes(mat)
```
```{r}
# To fill a matrix
mat<-matrix(1:6, nrow=2, ncol=3)
mat
```
```{r}
# To change the dim of the matrix by changing the dim attribute
dim(mat)<-c(3,2)
mat
```
### Use of factors
```{r}
# To use factors to label the results in the table
fac<-factor(c("yes", "yes", "no", "yes"))
fac
```
```{r}
# To see the labels of factor as table
table(fac)
```
### To find null values
```{r}
is.na(fac)
```
### To find nan values
```{r}
is.nan(fac)
```
### Dataframes in R
```{r}
# To create a dataframe in R
df<-data.frame(id=1:10, target=c(T,T,F,F,T,T,F,T,F,T), position=c(2,3,4,1,5,7,6,1,9,10), cost=c(21,32,NA,NA,4,23,24,76,12,9), season=c(1,1,1,2,2,2,3,3,3,4))
df
```
```{r}
# To see the number of rows
nrow(df)
```
```{r}
# To see the number of columns
ncol(df)
```
```{r}
# To see the names of the columns
names(df)
```
```{r}
# To obtain the value of a DF using the column name and the row number
df[7,"cost"]
```
```{r}
# To know how many missing values are in a column
cst_na=is.na(df["cost"])
table(cst_na)
```
```{r}
# Calculate the mean removing the na values
cst=df["cost"]
cst=cst[!cst_na]
mean(cst)
```
### Extract a subset of rows with logic and calculate the mean of a column
```{r}
# First remove missing values
subset<-df[complete.cases(df$cost, df$season, df$position), ]
subset
```
```{r}
# Use the logical operators to get the subset
log<-subset[subset$cost>21 & subset$season>1,]
# Calculate the mean of the column "position"
pos<-log[["season"]]
mean(pos)
```
```{r}
# Find the Maximum value in the "cost" column given a logical condition
df2<-df[df$season==2,]
df2<-df2[["cost"]]
max(df2, na.rm=TRUE)
```
### To create a list with names
```{r}
list_x1<-list(a=1,b=2,c=3)
list_x1
```
### To create a matrix with names
```{r}
mat2<-matrix(1:4,nrow=2, ncol=2)
dimnames(mat2)<-list(c("a","b"),c("c","d"))
mat2
```
### If else control structure
```{r}
x<-2
if (x==2){
        y<-1
}else{
        y<-0
}
y  
```
#### else if case
```{r}
a<-1
if (x==1){
        y<-4
}else if(a==1){
        y<-0
}
print(y)
```
### For control structure
```{r}
for (i in 1:3){
        print(i)
} 
```
#### Use of seq_along()
```{r}
x<-c("a","b","c","d")
for (i in seq_along(x)){
        print(x[i])
}
```
#### Nested loop
```{r}
x<-matrix(1:6, 2,3)
for (i in seq_len(nrow(x))){
        for (j in seq_len(ncol(x))){
                print(x[i,j])
        }
}
```
### While control structure
```{r}
count<-0
while(count<5){
        print(count)
        count<-count+1
}
```
### Repeat and break control structure
```{r}
value<-100000
div<-2
tol<- 1e-8
iter<-0
repeat{
        value<-value/div
        if(value<tol){
                print(iter)
                break
        }else{
                iter<-iter+1    
        } 
}
```
### Next control structure
```{r}
goal<-4
for (i in 1:6){
        if (goal==i){
                print("you are there")
                next
        } 
        print(i)
}
```
### Create a function
```{r}
add_func<-function(x,y){
        x+y
}
add_func(4,3)
```
### Create function with default
```{r}
add_func2<-function(x,y=3){
        x+y
}
add_func2(2)
```
### Dates and time in R

#### Assign a date
```{r}
x<-as.Date("1970-01-01")
x
```
#### Actual system time
```{r}
x<-Sys.time()
x #it is in POSIXct
```
#### To get info from POSIXlt
```{r}
p<-as.POSIXlt(x)
p$sec
```
### Lapply structure
```{r}
x<-list(a=1:4, b=rnorm(10))
lapply(x, mean)
```
#### Lapply structure with arguments for the function
```{r}
x<-1:3
lapply(x, runif, min=0, max=10)
```
#### Lapply structure to take the subset of a matrix
lapply() takes a vector object and passes each item in the vector through a function.
Each time an iten is passed, the return method stores the value in a list
```{r}
# lapply to a vector
vectorA <- 1:3
listA<-lapply(vectorA, sqrt)
listA
```
```{r}
# lapply with a matrix
x<-list(a=matrix(1:4,2,2), b=matrix(1:6,3,2))
lapply(x, function(elt) elt[,1])
```
```{r}
# To not get a list but a vector
unlist(listA)
```
```{r}
# lapply With a dataframe
listB <- list(data.frame(x=1:3, y=1:3*2), data.frame(x=4:6, y=4:6*2))
lapply(listB, sum)
```
### Use an anonymous function with lapply
Each dataframe is passed through the function as the data argument, all the results are saved and returned in a list
```{r}
# sqrt of the values in the x column of both dataframes
lapply(listB, function(data) sqrt(data$x))
```
### To use column names with lapply
```{r}
my_column <- "x"
unlist( lapply(listB, function(data) data[[my_column]]) )
```
### Sapply structure: lapply without the unlist incorporated
- If the result is a list where every element is length 1, it returns a vector.
- If the result is a list with every element of equal length, it returns a matrix.
- If it cannot figure it out, returns the same as lapply
```{r}
sapply(listB, function(data) data[[my_column]]) 
```
### Apply structure
It takes the list, the margin, the function and if possible the arguments of the function
```{r}
x<-matrix(rnorm(200), 20, 10) 
apply(x, 2, mean) # 2 To keep column dimension
```
```{r}
apply(x, 1, mean) # 1 to keep row dimension
```
There are shortcuts for specific cases of apply as rowSums, rowMeans, colSums and colMeans
```{r}
rowSums(x)
```
#### Calculate quantiles with apply
```{r}
apply(x, 1, quantile, probs=c(0.25,0.75))
```
#### Calculate the mean using apply of a matrix of 3 dimensions
```{r}
a<-array(rnorm(2*2*10), c(2,2,10))
apply(a,c(1,2), mean)
```
```{r}
rowMeans(a,dims=2)
```
### Mapply structure
when more than one argument is needed
```{r}
mapply(rep, 1:3, 3:1)
```
#### Vectorizing a function
```{r}
noise<-function(n,mean,sd){
        rnorm(n, mean, sd)
}
mapply(noise, 1:3, 1:3,2)
```
The same as 
```{r}
list(noise(1,1,2), noise(2,2,2), noise(3,3,2))
```
### Tapply structure
```{r}
x<-c(rnorm(10), runif(10), rnorm(10,1))
f<-gl(3,10)
f
```
```{r}
tapply(x, f, mean)
```
### Split structure
Split the dataframe by monthly pieces and calculate the mean of each month's attributes
```{r}
s<-split(airquality, airquality$Month)
sapply(s, function(x) colMeans(x[,c("Ozone", "Solar.R", "Wind")], na.rm=TRUE))
```